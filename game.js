// Generated by CoffeeScript 1.12.7
(function() {
  var Ball, Block, ClientGame, Game, ServerGame, _, exports,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  exports = exports != null ? exports : this;

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore');
  } else {
    _ = window._;
  }

  Game = (function() {
    function Game(conf1) {
      this.conf = conf1;
      this.state = this.initialState();
      this.callbacks = {};
      this.playIntervalId = null;
    }

    Game.prototype.initialState = function() {
      var block, objects;
      objects = this.initialObjects();
      return {
        ball: new Ball(objects.ball.x, objects.ball.y, this.conf.ball.radius, objects.ball.xVelocity, objects.ball.yVelocity),
        blocks: (function() {
          var j, len, ref, results;
          ref = objects.blocks;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            block = ref[j];
            results.push(new Block(block.x, block.y, this.conf.block.size.x, this.conf.block.size.y));
          }
          return results;
        }).call(this),
        lastUpdate: null,
        score: [0, 0]
      };
    };

    Game.prototype.initialObjects = function() {
      var centerY;
      centerY = this.conf.board.size.y / 2 - this.conf.block.size.y / 2;
      return {
        ball: {
          x: this.conf.ball.radius + 1,
          y: this.conf.ball.radius + 1,
          xVelocity: this.conf.ball.xVelocity,
          yVelocity: this.conf.ball.yVelocity
        },
        blocks: [
          {
            x: 0,
            y: centerY
          }, {
            x: this.conf.board.size.x - this.conf.block.size.x,
            y: centerY
          }
        ]
      };
    };

    Game.prototype.resetBall = function() {
      var objects;
      objects = this.initialObjects();
      this.state.ball.x = objects.ball.x;
      this.state.ball.y = objects.ball.y;
      this.state.ball.xVelocity = objects.ball.xVelocity;
      this.state.ball.yVelocity = objects.ball.yVelocity;
      return this.publish('reset', null);
    };

    Game.prototype.cloneState = function(other) {
      var b, x;
      return x = {
        ball: new Ball(other.ball.x, other.ball.y, other.ball.radius, other.ball.xVelocity, other.ball.yVelocity),
        blocks: (function() {
          var j, len, ref, results;
          ref = other.blocks;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            b = ref[j];
            results.push(b.clone());
          }
          return results;
        })(),
        lastUpdate: other.lastUpdate,
        score: _.clone(other.score)
      };
    };

    Game.prototype.start = function(drift) {
      var gameUpdate;
      drift = drift != null ? drift : 0;
      this.state.lastUpdate = (new Date).getTime() - drift;
      gameUpdate = (function(_this) {
        return function() {
          return _this.play(drift);
        };
      })(this);
      return this.playIntervalId = setInterval(gameUpdate, this.conf.update.timerAccuracy);
    };

    Game.prototype.stop = function() {
      console.log('Game stopped');
      clearInterval(this.playIntervalId);
      return this.playIntervalId = null;
    };

    Game.prototype.play = function(drift) {
      throw "play is not implemented in abstract base class Game";
    };

    Game.prototype.pongMove = function(timeDelta) {
      this.state.ball.move(timeDelta);
      return this.collisionCheck(timeDelta);
    };

    Game.prototype.collisionCheck = function(timeDelta) {
      var ball, block, blockMiddle, blocks, bounce, collision, distToMiddle, j, len, playerPoint;
      ball = this.state.ball;
      blocks = this.state.blocks;
      collision = false;
      for (j = 0, len = blocks.length; j < len; j++) {
        block = blocks[j];
        bounce = this.blockPong(block);
        if (bounce.x || bounce.y) {
          collision = true;
          ball.moveBack(timeDelta);
          if (bounce.x) {
            ball.horizontalPong();
          }
          if (bounce.y) {
            ball.verticalPong();
          }
          if (!this.conf.demoMode) {
            blockMiddle = block.height / 2;
            distToMiddle = (Math.abs(ball.y - (block.top() + blockMiddle)) - ball.radius) / blockMiddle;
            ball.horizontalAccelerate(this.conf.ball.accelerationFromPaddle * distToMiddle);
          }
          ball.move(timeDelta);
          break;
        }
      }
      if (this.horizontalWallCollision()) {
        collision = true;
        ball.moveBack(timeDelta);
        ball.verticalPong();
        ball.move(timeDelta);
      }
      playerPoint = this.checkForPoint();
      if (playerPoint != null) {
        collision = true;
        if (this.conf.demoMode) {
          ball.moveBack(timeDelta);
          ball.horizontalPong();
          ball.move(timeDelta);
        } else {
          this.onPoint(playerPoint);
        }
      }
      return collision;
    };

    Game.prototype.blockPong = function(block) {
      var ball, bounce, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, xWithin, yWithin;
      ball = this.state.ball;
      xWithin = (block.left() <= (ref = ball.right()) && ref <= block.right()) || (block.left() <= (ref1 = ball.left()) && ref1 <= block.right()) || ((ball.left() <= (ref3 = block.left()) && ref3 <= (ref2 = block.right())) && ref2 <= ball.right());
      yWithin = (block.top() <= (ref4 = ball.bottom()) && ref4 <= block.bottom()) || (block.top() <= (ref5 = ball.top()) && ref5 <= block.bottom()) || ((ball.top() <= (ref7 = block.top()) && ref7 <= (ref6 = block.bottom())) && ref6 <= ball.bottom());
      bounce = {
        x: yWithin && ((ball.xVelocity > 0 && Math.abs(ball.x - block.left()) <= ball.radius) || (ball.xVelocity < 0 && Math.abs(ball.x - block.right()) <= ball.radius)),
        y: xWithin && ((ball.yVelocity > 0 && Math.abs(ball.y - block.top()) <= ball.radius) || (ball.yVelocity < 0 && Math.abs(ball.y - block.bottom()) <= ball.radius))
      };
      return bounce;
    };

    Game.prototype.horizontalWallCollision = function() {
      return this.state.ball.top() <= 0 || this.state.ball.bottom() >= this.conf.board.size.y;
    };

    Game.prototype.checkForPoint = function() {
      if (this.state.ball.left() <= 0) {
        return 1;
      } else if (this.state.ball.right() >= this.conf.board.size.x) {
        return 0;
      } else {
        return null;
      }
    };

    Game.prototype.onPoint = function(playerPoint) {
      this.state.score[playerPoint] += 1;
      return this.resetBall();
    };

    Game.prototype.update = function(state) {
      var b, i, j, len, ref;
      this.state.lastUpdate = state.lastUpdate;
      this.state.ball.update(state.ball);
      ref = this.state.blocks;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        b = ref[i];
        b.update(state.blocks[i]);
      }
      this.state.score = _.clone(state.score);
      return this.publish('update', this.state);
    };

    Game.prototype.on = function(event, callback) {
      if (!(event in this.callbacks)) {
        this.callbacks[event] = [];
      }
      return this.callbacks[event].push(callback);
    };

    Game.prototype.publish = function(event, data) {
      var callback, j, len, ref, results;
      if (event in this.callbacks) {
        ref = this.callbacks[event];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          callback = ref[j];
          results.push(callback(event, data));
        }
        return results;
      }
    };

    return Game;

  })();

  ServerGame = (function(superClass) {
    extend(ServerGame, superClass);

    function ServerGame(conf) {
      ServerGame.__super__.constructor.call(this, conf);
      this.inputUpdates = [this.initialInputUpdate(), this.initialInputUpdate()];
    }

    ServerGame.prototype.initialInputUpdate = function() {
      return {
        updates: [],
        inputIndex: -1
      };
    };

    ServerGame.prototype.play = function(drift) {
      var currentTime, timeDelta;
      currentTime = (new Date()).getTime();
      timeDelta = currentTime - this.state.lastUpdate;
      if (timeDelta >= this.conf.update.interval) {
        this.processInputs();
        this.pongMove(timeDelta);
        this.state.lastUpdate = currentTime;
        return this.publish('update', this.state);
      }
    };

    ServerGame.prototype.processInputs = function() {
      var block, blockId, cmd, input, j, k, l, len, len1, len2, ref, ref1, ref2, results, updateEntry;
      ref = this.inputUpdates;
      results = [];
      for (blockId = j = 0, len = ref.length; j < len; blockId = ++j) {
        updateEntry = ref[blockId];
        if (!(updateEntry.updates.length > 0)) {
          continue;
        }
        block = this.state.blocks[blockId];
        ref1 = updateEntry.updates;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          input = ref1[k];
          ref2 = input.buffer;
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            cmd = ref2[l];
            block.move(cmd, input.duration, this.conf.board.size.y);
          }
        }
        updateEntry.inputIndex = (_.last(updateEntry.updates)).index;
        results.push(updateEntry.updates = []);
      }
      return results;
    };

    ServerGame.prototype.addInputUpdate = function(blockId, data) {
      return this.inputUpdates[blockId].updates.push(data);
    };

    ServerGame.prototype.inputIndex = function(blockId) {
      return this.inputUpdates[blockId].inputIndex;
    };

    return ServerGame;

  })(Game);

  ClientGame = (function(superClass) {
    extend(ClientGame, superClass);

    ClientGame.SERVERUPDATES = 100;

    function ClientGame(conf) {
      ClientGame.__super__.constructor.call(this, conf);
      this.blockId = null;
      this.serverUpdates = [];
      this.inputsBuffer = [];
      this.inputIndex = 0;
    }

    ClientGame.prototype.play = function(drift) {
      var currentTime, timeDelta;
      currentTime = (new Date).getTime() - drift;
      if (this.conf.client.interpolate) {
        currentTime -= this.conf.client.interpLatency;
      }
      timeDelta = currentTime - this.state.lastUpdate;
      if (timeDelta >= this.conf.update.interval) {
        this.sampleInput(timeDelta);
        this.inputPredict();
        if (!this.conf.client.interpolate) {
          this.noInterpolation(currentTime);
          this.collisionCheck(timeDelta);
        } else if (this.conf.client.optimizedLinearInterpolate) {
          this.optimizedLinearInterpolation(currentTime);
          this.collisionCheck(timeDelta);
        } else if (this.conf.client.regularLinearInterpolate) {
          this.regularLinearInterpolation(currentTime);
          this.collisionCheck(timeDelta);
        }
        this.state.lastUpdate = currentTime;
        return this.publish('update', this.state);
      }
    };

    ClientGame.prototype.inputPredict = function() {
      var dir, input, j, len, ref, results;
      if (this.conf.client.interpolate) {
        this.controlledBlock().y = (_.last(this.serverUpdates)).state.blocks[this.blockId].y;
      }
      ref = this.inputsBuffer;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        input = ref[j];
        results.push((function() {
          var k, len1, ref1, results1;
          ref1 = input.buffer;
          results1 = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            dir = ref1[k];
            this.controlledBlock().move(dir, input.duration, this.conf.board.size.y);
            if (!this.conf.client.interpolate) {
              results1.push(input.buffer = []);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    ClientGame.prototype.regularLinearInterpolation = function(now) {
      var block, blockId, i, j, k, len, lerp, next, prev, ref, ref1, results, t, updateCount;
      updateCount = this.serverUpdates.length;
      if (updateCount < 2) {
        return;
      }
      i = _.find((function() {
        results = [];
        for (var j = 1, ref = updateCount - 1; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this), (function(_this) {
        return function(i) {
          return (_this.serverUpdates[i - 1].state.lastUpdate <= now && now <= _this.serverUpdates[i].state.lastUpdate);
        };
      })(this));
      if (i == null) {
        console.log("Cannot interpolate. Client time " + now + ", last server update at " + (_.last(this.serverUpdates)).state.lastUpdate);
        return;
      }
      prev = this.serverUpdates[i - 1].state;
      next = this.serverUpdates[i].state;
      lerp = function(p, n, t) {
        return p + t * (n - p);
      };
      t = (now - prev.lastUpdate) / (next.lastUpdate - prev.lastUpdate);
      if (Math.max(Math.abs(prev.ball.x - next.ball.x), Math.abs(prev.ball.y - next.ball.y)) <= this.conf.client.maxInterp) {
        this.state.ball.x = lerp(prev.ball.x, next.ball.x, t);
        this.state.ball.y = lerp(prev.ball.y, next.ball.y, t);
      }
      ref1 = this.state.blocks;
      for (blockId = k = 0, len = ref1.length; k < len; blockId = ++k) {
        block = ref1[blockId];
        if (blockId !== this.blockId) {
          block.y = lerp(prev.blocks[blockId].y, next.blocks[blockId].y, t);
        }
      }
      this.state.score = prev.score;
      return this.publish('point', this.state.score);
    };

    ClientGame.prototype.optimizedLinearInterpolation = function(now) {
      var block, blockId, i, j, k, len, lerp, next, prev, ref, ref1, results, t, updateCount;
      updateCount = this.serverUpdates.length;
      if (updateCount < 2) {
        return;
      }
      i = _.find((function() {
        results = [];
        for (var j = 1, ref = updateCount - 1; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this), (function(_this) {
        return function(i) {
          return (_this.serverUpdates[i - 1].state.lastUpdate <= now && now <= _this.serverUpdates[i].state.lastUpdate);
        };
      })(this));
      if (i == null) {
        console.log("Cannot interpolate. Client time " + now + ", last server update at " + (_.last(this.serverUpdates)).state.lastUpdate);
        return;
      }
      prev = this.serverUpdates[i - 1].state;
      next = this.serverUpdates[i].state;
      lerp = function(p, n, t) {
        return (1 - t) * p + (t * n);
      };
      t = (now - prev.lastUpdate) / (next.lastUpdate - prev.lastUpdate);
      if (Math.max(Math.abs(prev.ball.x - next.ball.x), Math.abs(prev.ball.y - next.ball.y)) <= this.conf.client.maxInterp) {
        this.state.ball.x = lerp(prev.ball.x, next.ball.x, t);
        this.state.ball.y = lerp(prev.ball.y, next.ball.y, t);
      }
      ref1 = this.state.blocks;
      for (blockId = k = 0, len = ref1.length; k < len; blockId = ++k) {
        block = ref1[blockId];
        if (blockId !== this.blockId) {
          block.y = lerp(prev.blocks[blockId].y, next.blocks[blockId].y, t);
        }
      }
      this.state.score = prev.score;
      return this.publish('point', this.state.score);
    };

    ClientGame.prototype.noInterpolation = function(now) {
      var block, blockId, i, j, k, len, next, prev, ref, ref1, results, t, updateCount;
      updateCount = this.serverUpdates.length;
      if (updateCount < 2) {
        return;
      }
      i = _.find((function() {
        results = [];
        for (var j = 1, ref = updateCount - 1; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this), (function(_this) {
        return function(i) {
          return (_this.serverUpdates[i - 1].state.lastUpdate <= now && now <= _this.serverUpdates[i].state.lastUpdate);
        };
      })(this));
      if (i == null) {
        console.log("Cannot interpolate. Client time " + now + ", last server update at " + (_.last(this.serverUpdates)).state.lastUpdate);
        return;
      }
      prev = this.serverUpdates[i - 1].state;
      next = this.serverUpdates[i].state;
      t = (now - prev.lastUpdate) / (next.lastUpdate - prev.lastUpdate);
      if (Math.max(Math.abs(prev.ball.x - next.ball.x), Math.abs(prev.ball.y - next.ball.y)) <= this.conf.client.maxInterp) {
        this.state.ball.x = next.ball.x;
        this.state.ball.y = next.ball.y;
      }
      ref1 = this.state.blocks;
      for (blockId = k = 0, len = ref1.length; k < len; blockId = ++k) {
        block = ref1[blockId];
        if (blockId !== this.blockId) {
          block.y = next.blocks[blockId].y;
        }
      }
      this.state.score = prev.score;
      return this.publish('point', this.state.score);
    };

    ClientGame.prototype.sampleInput = function(timeDelta) {
      var inputEntry, inputs;
      inputs = [];
      if (this.controlledBlock().movingUp) {
        inputs.push('up');
      }
      if (this.controlledBlock().movingDown) {
        inputs.push('down');
      }
      if (inputs.length > 0) {
        this.inputIndex += 1;
        inputEntry = {
          buffer: inputs,
          index: this.inputIndex,
          duration: timeDelta
        };
        console.log("Sending update to server", inputEntry);
        this.inputsBuffer.push(inputEntry);
        return this.publish('input', inputEntry);
      }
    };

    ClientGame.prototype.addServerUpdate = function(update) {
      if (this.conf.client.interpolate) {
        this.serverUpdates.push(update);
        if (this.serverUpdates.length > ClientGame.SERVERUPDATES) {
          this.serverUpdates.splice(0, 1);
        }
      } else {
        this.update(update.state);
      }
      return this.discardAcknowledgedInput(update);
    };

    ClientGame.prototype.discardAcknowledgedInput = function(serverUpdate) {
      var input;
      return this.inputsBuffer = (function() {
        var j, len, ref, results;
        ref = this.inputsBuffer;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          input = ref[j];
          if (input.index > serverUpdate.inputIndex) {
            results.push(input);
          }
        }
        return results;
      }).call(this);
    };

    ClientGame.prototype.setBlock = function(blockId1) {
      this.blockId = blockId1;
    };

    ClientGame.prototype.controlledBlock = function() {
      if (this.blockId != null) {
        return this.state.blocks[this.blockId];
      }
    };

    return ClientGame;

  })(Game);

  Block = (function() {
    function Block(x1, y, width, height) {
      this.x = x1;
      this.y = y;
      this.width = width;
      this.height = height;
      this.movingUp = 0;
      this.movingDown = 0;
    }

    Block.prototype.clone = function() {
      return new Block(this.x, this.y, this.width, this.height);
    };

    Block.prototype.update = function(data) {
      this.x = data.x;
      this.y = data.y;
      this.width = data.width;
      return this.height = data.height;
    };

    Block.prototype.top = function() {
      return this.y;
    };

    Block.prototype.bottom = function() {
      return this.y + this.height;
    };

    Block.prototype.left = function() {
      return this.x;
    };

    Block.prototype.right = function() {
      return this.x + this.width;
    };

    Block.prototype.move = function(dir, duration, maxValue) {
      switch (dir) {
        case 'down':
          return this.moveDown(duration, maxValue);
        case 'up':
          return this.moveUp(duration, maxValue);
        default:
          throw "Block can only move up and down, not " + dir;
      }
    };

    Block.prototype.moveUp = function(t) {
      return this.y = Math.max(this.y - t * 0.5, 0);
    };

    Block.prototype.moveDown = function(t, maxY) {
      return this.y = Math.min(this.y + t * 0.5, maxY - this.height);
    };

    return Block;

  })();

  Ball = (function() {
    function Ball(x1, y, radius, xVelocity, yVelocity) {
      this.x = x1;
      this.y = y;
      this.radius = radius;
      this.xVelocity = xVelocity;
      this.yVelocity = yVelocity;
    }

    Ball.prototype.update = function(data) {
      this.x = data.x;
      this.y = data.y;
      this.xVelocity = data.xVelocity;
      this.yVelocity = data.yVelocity;
      return this.radius = data.radius;
    };

    Ball.prototype.move = function(t) {
      this.x += this.xVelocity * t;
      return this.y += this.yVelocity * t;
    };

    Ball.prototype.moveBack = function(t) {
      return this.move(-t);
    };

    Ball.prototype.horizontalAccelerate = function(dxv) {
      if (this.xVelocity > 0) {
        return this.xVelocity += dxv;
      } else {
        return this.xVelocity -= dxv;
      }
    };

    Ball.prototype.verticalPong = function() {
      return this.yVelocity = -this.yVelocity;
    };

    Ball.prototype.horizontalPong = function() {
      return this.xVelocity = -this.xVelocity;
    };

    Ball.prototype.left = function() {
      return this.x - this.radius;
    };

    Ball.prototype.right = function() {
      return this.x + this.radius;
    };

    Ball.prototype.top = function() {
      return this.y - this.radius;
    };

    Ball.prototype.bottom = function() {
      return this.y + this.radius;
    };

    return Ball;

  })();

  exports.WebPongJSServerGame = ServerGame;

  exports.WebPongJSClientGame = ClientGame;

  exports.WebPongJSBall = Ball;

  exports.WebPongJSBlock = Block;

}).call(this);
